<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tank Combat Game</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      background: #111;
      color: white;
      font-family: Arial, sans-serif;
    }
    
    canvas {
      background: #000;
      border: 2px solid #333;
    }
    
    #game-container {
      position: relative;
    }
    
    #ui-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      padding: 10px;
      box-sizing: border-box;
    }
    
    .health-bar {
      height: 15px;
      margin-bottom: 5px;
      background: #333;
      position: relative;
    }
    
    .health-bar-fill {
      height: 100%;
      width: 100%;
      background: linear-gradient(to right, #f00, #0f0);
      transition: width 0.3s;
    }
    
    .player-info {
      display: flex;
      justify-content: space-between;
      margin-bottom: 15px;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="ui-overlay">
      <div class="player-info">
        <div style="width: 45%;">
          <div>Player 1</div>
          <div class="health-bar">
            <div id="player1-health" class="health-bar-fill" style="width:100%"></div>
          </div>
        </div>
        <div style="width: 45%;">
          <div>Player 2</div>
          <div class="health-bar">
            <div id="player2-health" class="health-bar-fill" style="width:100%"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Game constants
    const PLAYER_RADIUS = 20;
    const PLAYER_SPEED = 3;
    const ROTATION_SPEED = 0.05;
    const BULLET_RADIUS = 5;
    const BULLET_SPEED = 5;
    const BOSS_RADIUS = 40;
    const BOSS_HEALTH = 100;
    const BOSS_SPEED = 1;
    const BOSS_SHOOT_INTERVAL = 2000;
    const TWO_PI = Math.PI * 2;
    
    // Canvas setup
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const CENTER_X = canvas.width / 2;
    const CENTER_Y = canvas.height / 2;
    
    // Game state
    let gameState = 'playing'; // 'playing', 'boss', 'gameOver'
    let keysPressed = {};
    
    // Player class definition
    class Player {
      constructor(x, y, color, controls) {
        this.x = x;
        this.y = y;
        this.radius = PLAYER_RADIUS;
        this.angle = 0;
        this.color = color;
        this.controls = controls;
        this.health = 100;
        this.lastShotTime = 0;
      }
      
      update(delta) {
        // Handle rotations
        if (keysPressed[this.controls.left]) {
          this.angle -= ROTATION_SPEED * delta;
        }
        if (keysPressed[this.controls.right]) {
          this.angle += ROTATION_SPEED * delta;
        }
        
        // Movement
        let dx = 0;
        let dy = 0;
        
        if (keysPressed[this.controls.up]) {
          dx = Math.cos(this.angle) * PLAYER_SPEED * (delta / 16);
          dy = Math.sin(this.angle) * PLAYER_SPEED * (delta / 16);
        }
        if (keysPressed[this.controls.down]) {
          dx = -Math.cos(this.angle) * PLAYER_SPEED * (delta / 16) * 0.5; // Reverse is slower
          dy = -Math.sin(this.angle) * PLAYER_SPEED * (delta / 16) * 0.5;
        }
        
        // Update position
        this.x += dx;
        this.y += dy;
        
        // Keep within bounds
        this.x = Math.max(this.radius, Math.min(canvas.width - this.radius, this.x));
        this.y = Math.max(this.radius, Math.min(canvas.height - this.radius, this.y));
        
        // Shooting
        const now = performance.now();
        if (keysPressed[this.controls.shoot] && now - this.lastShotTime > 500) {  // 500ms cooldown
          this.shoot();
          this.lastShotTime = now;
        }
        
        // Update UI health bar
        const healthBarElement = this === players[0] ? 
          document.getElementById('player1-health') : 
          document.getElementById('player2-health');
        
        if (healthBarElement) {
          healthBarElement.style.width = `${this.health}%`;
        }
      }
      
      draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        
        // Draw tank body
        ctx.beginPath();
        ctx.rect(-this.radius, -this.radius / 2, this.radius * 2, this.radius);
        ctx.fillStyle = this.color;
        ctx.fill();
        
        // Draw tank turret
        ctx.beginPath();
        ctx.rect(0, -2, this.radius, 4);
        ctx.fillStyle = '#fff';
        ctx.fill();
        
        ctx.restore();
      }
      
      shoot() {
        const bulletX = this.x + Math.cos(this.angle) * this.radius;
        const bulletY = this.y + Math.sin(this.angle) * this.radius;
        projectiles.push(new Projectile(bulletX, bulletY, this.angle, this));
      }
      
      takeDamage(amount) {
        this.health = Math.max(0, this.health - amount);
        if (this.health <= 0) {
          // Handle player defeat
          console.log(`${this === players[0] ? 'Player 1' : 'Player 2'} defeated!`);
        }
      }
    }
    
    // Projectile class definition
    class Projectile {
      constructor(x, y, angle, owner) {
        this.x = x;
        this.y = y;
        this.angle = angle;
        this.radius = BULLET_RADIUS;
        this.owner = owner;  // The player who shot this
        this.active = true;
      }
      
      update(delta) {
        // Move along angle
        this.x += Math.cos(this.angle) * BULLET_SPEED * (delta / 16);
        this.y += Math.sin(this.angle) * BULLET_SPEED * (delta / 16);
        
        // Check if out of bounds
        if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) {
          this.active = false;
        }
      }
      
      draw(ctx) {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, TWO_PI);
        ctx.fillStyle = 'yellow';
        ctx.fill();
      }
    }
    
    // Boss class definition
    class Boss {
      constructor() {
        this.x = CENTER_X;
        this.y = 100; // near top of arena
        this.radius = BOSS_RADIUS;
        this.health = BOSS_HEALTH;
        this.maxHealth = BOSS_HEALTH;
        this.vx = BOSS_SPEED;
        this.lastShotTime = 0;
      }
      
      update(delta) {
        // Simple horizontal oscillation
        this.x += this.vx;
        if (this.x < this.radius || this.x > canvas.width - this.radius) {
          this.vx = -this.vx;
        }
        
        // Boss shooting: fire projectiles in random directions toward the arena
        const now = performance.now();
        if (now - this.lastShotTime > BOSS_SHOOT_INTERVAL) {
          // Aim roughly downward with slight randomness
          let angle = Math.PI / 2 + (Math.random() - 0.5) * 0.5;
          bossProjectiles.push(new Projectile(this.x, this.y, angle, null));
          this.lastShotTime = now;
        }
      }
      
      draw(ctx) {
        // Boss drawn as a glowing red circle with health bar on top
        ctx.save();
        ctx.shadowBlur = 20;
        ctx.shadowColor = "red";
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, TWO_PI);
        ctx.fillStyle = "red";
        ctx.fill();
        ctx.restore();
        
        // Draw health bar
        const barWidth = 100;
        const barHeight = 10;
        const healthPct = this.health / this.maxHealth;
        ctx.fillStyle = "gray";
        ctx.fillRect(this.x - barWidth / 2, this.y - this.radius - 20, barWidth, barHeight);
        ctx.fillStyle = "lime";
        ctx.fillRect(this.x - barWidth / 2, this.y - this.radius - 20, barWidth * healthPct, barHeight);
      }
    }
    
    // Arrays to hold game objects
    let players = [];
    let projectiles = [];
    let bossProjectiles = [];
    let boss = null;
    
    // Initialize players with starting positions and their controls
    players.push(
      new Player(100, canvas.height - 100, "cyan", {
        left: "KeyA",
        right: "KeyD",
        up: "KeyW",
        down: "KeyS",
        shoot: "Space",
      })
    );
    players.push(
      new Player(canvas.width - 100, canvas.height - 100, "lime", {
        left: "ArrowLeft",
        right: "ArrowRight",
        up: "ArrowUp",
        down: "ArrowDown",
        shoot: "Enter",
      })
    );
    
    // Input event listeners
    window.addEventListener("keydown", (e) => {
      keysPressed[e.code] = true;
      // Prevent default actions for our chosen keys
      if (
        ["KeyW", "KeyA", "KeyS", "KeyD", "Space", "ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "Enter"].includes(e.code)
      ) {
        e.preventDefault();
      }
    });
    
    window.addEventListener("keyup", (e) => {
      keysPressed[e.code] = false;
    });
    
    // Game loop with timestamp for frame rate independence
    let lastTime = 0;
    function gameLoop(timestamp) {
      // Calculate delta time for frame rate independence
      const delta = timestamp - lastTime;
      lastTime = timestamp;
      
      // Clear the canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Update and draw based on game state
      if (gameState === 'playing') {
        runGameplay(delta);
      } else if (gameState === 'boss') {
        runBossBattle(delta);
      }
      
      // Continue the loop
      requestAnimationFrame(gameLoop);
    }
    
    function runGameplay(delta) {
      // Update and draw players
      for (const player of players) {
        player.update(delta);
        player.draw(ctx);
      }
      
      // Update and draw projectiles
      for (let i = projectiles.length - 1; i >= 0; i--) {
        const projectile = projectiles[i];
        projectile.update(delta);
        projectile.draw(ctx);
        
        // Check for collisions with players
        for (const player of players) {
          if (projectile.owner !== player) {  // Can't hit self
            const dx = projectile.x - player.x;
            const dy = projectile.y - player.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < projectile.radius + player.radius) {
              // Collision detected
              player.takeDamage(10);
              projectile.active = false;
              break;
            }
          }
        }
        
        // Remove inactive projectiles
        if (!projectile.active) {
          projectiles.splice(i, 1);
        }
      }
      
      // Check if it's time to trigger the boss battle (e.g., after a timer or score threshold)
      // For this demo, we'll trigger it after 30 seconds
      if (timestamp > 30000 && !boss) {
        startBossBattle();
      }
    }
    
    function startBossBattle() {
      gameState = 'boss';
      boss = new Boss();
      // Could also change the background or play a special sound here
    }
    
    function runBossBattle(delta) {
      // Still update and draw players
      for (const player of players) {
        player.update(delta);
        player.draw(ctx);
      }
      
      // Update and draw the boss
      boss.update(delta);
      boss.draw(ctx);
      
      // Update and draw player projectiles
      for (let i = projectiles.length - 1; i >= 0; i--) {
        const projectile = projectiles[i];
        projectile.update(delta);
        projectile.draw(ctx);
        
        // Check for collision with boss
        const dx = projectile.x - boss.x;
        const dy = projectile.y - boss.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < projectile.radius + boss.radius) {
          // Hit the boss
          boss.health -= 5;
          projectile.active = false;
          
          if (boss.health <= 0) {
            // Boss defeated!
            gameState = 'playing';
            boss = null;
            break;
          }
        }
        
        // Remove inactive projectiles
        if (!projectile.active) {
          projectiles.splice(i, 1);
        }
      }
      
      // Update and draw boss projectiles
      for (let i = bossProjectiles.length - 1; i >= 0; i--) {
        const projectile = bossProjectiles[i];
        projectile.update(delta);
        projectile.draw(ctx);
        
        // Check for collisions with players
        for (const player of players) {
          const dx = projectile.x - player.x;
          const dy = projectile.y - player.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance < projectile.radius + player.radius) {
            // Collision detected
            player.takeDamage(15);  // Boss projectiles do more damage
            projectile.active = false;
            break;
          }
        }
        
        // Remove inactive projectiles
        if (!projectile.active) {
          bossProjectiles.splice(i, 1);
        }
      }
    }
    
    // Start the game loop
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>