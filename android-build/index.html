
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <title>My Game</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { width: 100vw; height: 100vh; display: block; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        
        

        let paddle = {
            x: canvas.width / 2 - 40,
            y: canvas.height - 30,
            width: 80,
            height: 10,
            speed: 6,
            dx: 0
        };

        let bombs = [];
        let bombSpeed = 2;
        let bombInterval = 2000;
        let lastBombTime = 0;

        let shields = [];
        let shieldActive = false;
        let shieldDuration = 0;

        let score = 0;
        let lives = 3;
        let gameOver = false;

        // Draw paddle
        function drawPaddle() {
            ctx.fillStyle = 'white';
            ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);
        }

        // Draw bombs
        function drawBombs() {
            ctx.fillStyle = 'red';
            bombs.forEach(bomb => {
                ctx.beginPath();
                ctx.arc(bomb.x, bomb.y, 5, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // Draw shields
        function drawShields() {
            if(shieldActive) {
                ctx.strokeStyle = 'cyan';
                ctx.lineWidth = 2;
                ctx.strokeRect(paddle.x - 5, paddle.y - 5, paddle.width + 10, paddle.height + 10);
            }
        }

        // Draw score and lives
        function drawScore() {
            ctx.font = '16px Arial';
            ctx.fillStyle = 'white';
            ctx.fillText(`Score: ${score}`, 8, 20);
            ctx.fillText(`Lives: ${lives}`, canvas.width - 70, 20);
        }

        // Create a new bomb
        function createBomb() {
            const x = Math.random() * (canvas.width - 10) + 5;
            bombs.push({ x, y: 0 });
        }

        // Create a shield power-up
        function createShield() {
            const x = Math.random() * (canvas.width - 20) + 10;
            shields.push({ x, y: 0 });
        }

        // Update the game objects
        function update(deltaTime) {
            if (!gameOver) {
                // Move paddle
                paddle.x += paddle.dx;
                if (paddle.x < 0) paddle.x = 0;
                if (paddle.x + paddle.width > canvas.width) paddle.x = canvas.width - paddle.width;

                // Move bombs
                bombs.forEach(bomb => {
                    bomb.y += bombSpeed;
                    if (bomb.y > canvas.height) {
                        if (!shieldActive) {
                            lives--;
                            if (lives <= 0) gameOver = true;
                        }
                        bombs.shift();
                    }
                });

                // Check bomb collisions with paddle
                bombs.forEach((bomb, index) => {
                    if (bomb.x > paddle.x && bomb.x < paddle.x + paddle.width && bomb.y > paddle.y && bomb.y < paddle.y + paddle.height) {
                        score++;
                        bombs.splice(index, 1);
                        if (score % 5 === 0) createShield(); // Create a shield every 5 points
                    }
                });

                // Move shields
                shields.forEach((shield, index) => {
                    shield.y += bombSpeed;
                    if (shield.y > canvas.height) {
                        shields.shift();
                    }
                });

                // Check shield collisions with paddle
                shields.forEach((shield, index) => {
                    if (shield.x > paddle.x && shield.x < paddle.x + paddle.width && shield.y > paddle.y && shield.y < paddle.y + paddle.height) {
                        shieldActive = true;
                        shieldDuration = 3000; // Shield active for 3 seconds
                        shields.splice(index, 1);
                    }
                });

                // Update shield duration
                if (shieldActive) {
                    shieldDuration -= deltaTime;
                    if (shieldDuration <= 0) {
                        shieldActive = false;
                    }
                }

                // Increase difficulty over time
                bombSpeed += 0.001;
                if (Date.now() - lastBombTime > bombInterval) {
                    createBomb();
                    lastBombTime = Date.now();
                }
            }
        }

        // Render the game
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawPaddle();
            drawBombs();
            drawShields();
            drawScore();
        }

        // Main game loop
        function gameLoop(timestamp) {
            const deltaTime = timestamp - lastTimestamp;
            lastTimestamp = timestamp;

            update(deltaTime);
            render();

            if (!gameOver) {
                requestAnimationFrame(gameLoop);
            } else {
                ctx.fillStyle = 'red';
                ctx.font = '24px Arial';
                ctx.fillText('Game Over!', canvas.width / 2 - 60, canvas.height / 2);
            }
        }

        // Touch event to move paddle
        canvas.addEventListener('touchmove', (event) => {
            const touch = event.touches[0];
            const touchX = touch.clientX - canvas.offsetLeft;
            paddle.x = touchX - paddle.width / 2;
        });

        // Initialize game
        let lastTimestamp = 0;
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>